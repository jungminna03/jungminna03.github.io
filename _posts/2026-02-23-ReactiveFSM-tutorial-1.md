---
layout: post
title: "01. 사용 방법"
categories: [Reactive FSM]
---

## 사전 준비 

이 에셋은 R3 라이브러리에 의존성을 가진다. 

Github에서 <a href="https://github.com/GlitchEnzo/NuGetForUnity/tree/master" target="_blank" style="color: grey;">NuGetForUnity</a>의 페키지를 다운받아 유니티 프로젝트에 적용한 후 R3를 설치하면 된다.

## Reactive FSM 사용 방법 

Reactive FSM를 사용하기 위해서는 다음 2가지 요소를 구현해야한다. 

1. 행동-상태의 구현
2. Reactive FSM의 구현 

## 행동-상태의 구현 

이 FSM에서는 `IFSMState`라는 인터페이스를 제공한다. 이 **인터페이스(상태)를 구현하고 그 안에 실행될 코드(행동)를 담음**으로써 행동-상태를 구현할 수 있다. 

```
(인터페이스대로 정의만 한 코드)
```

인터페이스만 제공하는 이유는 각 State에서 행동을 할때 필요로 하는 리소스들을 미리 준비할 수 없기 때문이다. 따라서 사용자가 각 State에서 행동을 할때 필요로 하는 리소스를 직접 설정해서 사용하면 된다. 

특이한 점이 있다면 **Enter과 Exit는 있지만 Update가 없다**는 점이다. 

Update를 없앤 이유는 리액티브 프로그래밍의 특성상 실행될 코드를 선언부에 실행될 시점과 함께 정의해놓는다는 점을 그대로 채용했다는 점에 있다. 

행동을 미리 Exit안에 행동을 할 시점과 함께 등록(선언)하고, Exit에서는 그 등록을 지워주면 된다. 

또한 편리하게 등록을 지우기 위해 CompositeDisposable를 사용한다. (리액티브 프로그래밍에서 자주 사용되는 패턴이다.) 

```
(Enter에서 등록하고 Exit에서 해제하는 예시 코드)
```

만약 등록을 지우지 않는 실수가 일어나면 상태가 바뀔때마다 등록되어있던 스트림들이 계속 살아있게 되어 **메모리 누수**가 발생하게 된다.

이는 리액티브 프로그래밍에서 자주 일어나는 실수이다. 

위의 내용을 참고해 상태를 정의하면 다음과 같다. 

``` 

``` 

## Reactive FSM의 구현 

Reactive FSM을 구현하기 위해서는 다음 5개의 단계를 거치게 된다 

1. 구현 위치 선정
2. 상태 등록
3. 컨디션 등록
4. 룰 추가
5. 시작 

### 1. 구현 위치 선정 

FSM의 구현은 한 함수 안에서 전부 이루어진다. (회색 글씨로) 함수를 단계별로 나눠도 좋겠지만 구조적인 단순함을 위해서 전부 한 함수에서 진행했다. 

이 FSM이 어떻게 동작할지를 전부 정의한 함수이기 때문에 함수의 길이는 매우 길다. 

클래스가 여러 기능을 하고, 그 기능과 FSM의 구현이 전부 한 파일 안에 작성 됐다면 클래스의 가독성이 매우 떨어질 것이다. 

제작자는 partial을 적극적으로 추천하는 바이다. FSM의 구현만이라도 따로 파일을 만들어서 관리를 하면 가독성이 단번에 좋아진다.
대신 유지보수는 여러 파일을 왔다갔다 해야하기에 조금 어려워지는 면이 있다. 

예시 코드
```
(partial로 FSM구현부를 나눠놓은 코드)
```

### 2. 상태 등록 

FSM에게 어떤 상태가 있는지 알려줘서 FSM이 그 상태로 전이할 수 있게 해야한다. 

함수 원형
```
void AddState(IFSMState state);
```

예시 코드
```
함수를 생성하고 등록하는 코드
```

### 3. 컨디션 등록 

사실상 이 단계가 이 FSM을 Reactive하게 작동시키기 위한 가장 중요한 단계라고 생각할 수 있다. 또한 가장 어려운 단계이다. 

우선 스트림에 대한 설명을 먼저 해야한다. 스트림은 이 FSM이 작동하기 위한 원천과 같다. 스트림을 통해서 FSM은 언제 조건을 체크하고 상태를 바꿀지에 대한 타이밍을 나타낸다. 

```
(스트림을 만들어내는 코드)
```

이제 이 스트림을 가공을 해야할 단계이다. 어떤 타이밍에 FSM을 갱신할 것인지 결정했으니 이제는 그 타이밍에 무슨 조건을 어떻게 따질 것인지에 대해 결정해야한다. 

```
(스트림과 그 스트림을 가공한 코드)
```

가공한 스트림을 이제 FSM에 컨디션으로써 등록해서 이 스트림이 변경될때마다 FSM이 이 스트림에 맞게 상태를 전이하도록 해야한다. 

```
컨디션을 추가하는 코드
```

위에 단계를 거쳐서 컨디션을 등록하게 되는 것이다. 

함수 원형
```
void RegisterCondition(string name, Observable<bool> conditionStream);
```

예시 코드 전체
``` 

``` 

### 4. 룰 추가 및 우선순위 결정 

이제 마지막으로 각 컨디션이 어떤 상황일때 어떤 상태로 전이할 것인가, 또한 이 룰간에 우선순위는 어떻게 되는가에 대한 정보, 즉 어떻게 동작할 것인가에 대한 정보만 등록해주면 거의 끝이 난다고 볼 수 있다. 

이때 같은 조건이 충족되었을때 어떤 상태로 전환할지 우선순위를 정하는 것이 이 단계에서 가장 중요한 부분이다. 

함수 원형
``` 

``` 

예시 코드
```
룰을 추가하는 코드
```

### 5. 시작 

마지막으로 다음 함수를 호출해 FSM의 동작을 실행시키면 된다. 

함수 원형
```
void SetInitialState<T>() where T : IFSMState;
```

예시 코드
``` 

``` 

## 디버깅 

이렇게 생성된 FSM 인스턴스가 실제 게임 내에서 각 조건이 어떤 값인지, 또 어떤 상태인지 보고 싶으면 ~유니티에서 어디 메뉴 클릭하면 나오는지 알아보고 적기~를 통해 모니터링 에니터 윈도우를 열면 된다. 

(사진) 

왼쪽에 각 인스턴스의 이름이 나와있고, 그 이름의 버튼을 클릭하면 해당 인스턴스의 정보가 오른쪽에 표시된다. 

(사진) 

이때 각 인스턴스의 이름을 지정해주기 위해서는 ReactiveFSM의 생성자에서 이름으로 할 string을 넘겨주어야 한다. 

예시 코드
``` 

``` 

## 주의점 

~룰 추가할때 잘 고려해야함~

---
**References & Copyrights**
* **Images:** 본 문서의 도식 및 예시 이미지에는 AI 기술로 생성된 리소스가 일부 포함되어 있습니다.
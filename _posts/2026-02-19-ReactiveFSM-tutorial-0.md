---
title: "00. 개요"
categories: [Reactive FSM]
---

## 에셋 사용 대상 

이 에셋은 기본적으로 리엑티브 프로그래밍을 이용한 작은 규모의 게임을 개발하는 사람들을 위해 제작됐다. 

리엑티브 프로그래밍을 능숙하게 사용하는 사람들에게도 도움이 될 것이고, 리엑티브 프로그래밍에 관심이 있는, 사용하기 시작한 사람들이 연습을 함에 있어서도 도움이 될 것이다. 

또한 엔진과 분리된 FSM을 찾는 사람들에게도 도움이 될 것이다. 

엔진과는 아무런 관련도 없는 순수 C# 클래스이기에, 유니티 테스트 프레임워크나 엔진에 대한 의존성을 최대한 덜어내는 프레임워크를 사용하는 사람들에게도 도움이 될 것이다. 

## Reactive FSM을 만들게된 계기 

게임을 개발하다보면 FSM을 많이 만들어본 경험이 있을 것이다.

캐릭터 로직을 만들거나, 게임의 상태를 관리하는 등 여러 방면에서 FSM을 적용하면 여러 행동들을 쉽게 관리할 수 있다. 

그러나 FSM을 계속 만들다보니 공통되는 문제점이 눈에 밟혔다. 

## 기존 FSM의 문제점 

작은 수준의 FSM을 코드로 구현하려고 하면 **재활용하기 힘들거나** 작은 수준이어도 **복잡하게 트랜젝션을 연결**해야만 했다. **루프를 돌려주는 일**도 골치아픈 일이다. 또한 코드로 만들었기 때문에 디버깅중 어느 트랜지션으로 언제 넘어가는지 **디버깅**하는 것은 꽤나 골치 아픈 일이다. 

개선하고자하는 문제들을 정리해보면 다음과 같다.
1. Update
2. 간단한 사용
3. 재활용
4. 디버깅 

## 해결 방안 마련 

1. Update 

![업데이트 루프에서 FSM으로 흐름이 어렵게 흘러가는 사진](/assets/images/Project/log/purikone_ingame.jpg)
*[그림 1] 기존 FSM의 문제점 1*
기존 FSM에서의 귀찮은 작업 중 하나는 매 루프마다 조건을 체크하게 만들어야한다는 점이다. 

FSM에서 별도로 update문을 돌리거나 각 클래스의 update문에 FSM의 업데이트도 갱신시켜주는 코드를 한줄 추가해야한다. 

그런데 만약 순수 C#클래스여서 update문이 없다고 하면 프레임워크나 엔진에 있는 update흐름을 FSM까지 흘려줘야한다. 

작은 FSM이라면 그 FSM에게 흐름을 흘려주기까지의 코스트가 아까워지는 상황이 많다. 

리액티브 익스텐션을 사용하면 너무나도 깔끔하게 해결되는 상황이다. <small style="color: grey;">리액티브 익스텐션에 대한 내용은 <a href="https://qiita.com/toRisouP/items/48b9fa25df64d3c6a392" target="_blank" style="color: grey;">토리스프가 정리한 UniRx기본 강좌</a>에 잘 정리되어있다.</small>

![업데이트 루프에서 FSM으로 흐름이 어렵게 흘러가는 사진에서 흐름이 끊어지고 FSM이 스스로 반응하는 듯한 사진](/assets/images/Project/log/purikone_ingame.jpg)
*[그림 2] 기존 FSM의 문제 해결 방안 1*
update 흐름을 흘려주기보다 자기가 변화가 필요한 상황을 스스로 감지해서 스스로 변화하는 **반응형 FSM**을 만들고자 한 것이 처음 Reactive FSM을 만들고자한 계기가 되었다. 

2. 간단한 사용 

![상태와 상태별로 이동하는 조건 화살표가 적힌 그림](/assets/images/Project/log/purikone_ingame.jpg)
*[그림 3] 기존 FSM의 문제점 2*
각 상태별로 특정 조건이 충족이 되면 다른 상태로 넘어가게 만드는 것은 각 상태별로 다른 상태로 넘어가는 조건을 각각 만들어줘야한다. 상태가 많을때는 매우 편리하겠지만, 상태가 별로 없다면 귀찮은 작업일 뿐이다. 

각 상태별로가 다른 상태로 넘어가는 조건을 만드는 대신 **어떤 상태에 들어가기 위한 조건**을 만드는 것은 매우 간단할 것이다. 

![스위치를 바꾸면 색이 바뀌는 GIF](/assets/images/Project/log/purikone_ingame.jpg)
*[그림 4] 기존 FSM의 문제 해결 방안 2-1*
예를 들면 상태가 서있기, 움직이기, 점프(공중) 이렇게 3개만 있다면. 조건을 2개 만들어서 그 조건에 맞게 상태를 조절하면 간단할 것이다. 

조건1. 입력이 있는가?
조건2. 공중에 있는가? 

입력이 있으면 움직이기 상태, 공중에 있으면 점프 상태로 옮겨주기만하면 원하는 상태로 전이가 될것이다. 

이 **조건(컨디션)을 가지고 룰을 추가해서 상태를 전이하는 것**이 이 FSM의 컨셉이다. 리엑티브 라이브러리와도 잘 어울리는 컨셉이다. 

![조건 -> 룰 -> 상태 변이 그림](/assets/images/Project/log/purikone_ingame.jpg)
*[그림 5] 기존 FSM의 문제 해결 방안 2-2*
입력이 있는가? 라는 조건이 충족이 되면 입력 상태로 전이되라 라는 룰을 추가해주고, 공중에 있는가? 라는 조건이 충족이 되면 공중 상태로 전이하라 라는 룰을 추가하는 것이다. 

하지만 문제가 있다. 

만약 입력이 있는가?라는 조건도 충족이 되고, 공중에 있는가?라는 조건도 충족이 되면 어떤 룰을 따라야 할까? 

![조건 -> 룰 -> 상태 변이 그림](/assets/images/Project/log/purikone_ingame.jpg)
*[그림 6] 기존 FSM의 문제 해결 방안 2-3*
이것을 위해서 룰간의 **우선 순위**라는 개념을 넣었다. 

공중으로 전환하라 라는 룰의 우선순위가 더 크다면 입력이 있으면서 공중에 있어도 공중 상태로 전환이 돼서 내가 원하던 동작으로 잘 동작이 될 것이다. 

3. 재활용 

![클래스랑 밀착되어있는 FSM이 떨어져 나와서 하나의 부품이 된 사진](/assets/images/Project/log/purikone_ingame.jpg)
*[그림 7] 기존 FSM의 문제 해결 방안 3*
FSM을 적용하는 클래스별로 행동이 다 다르기 때문에 상태와 상태에 따른 행동을 FSM과 분리시키면 FSM을 재활용할 수 있다. 

이때 행동에는 해당 FSM을 적용하는 클래스가 행동을 할 수 있도록 해당 클래스의 정보가 들어가야 한다. 

그래서 각 상태는 인터페이스를 제공하여 사용자가 상속을 통해 필요한 정보를 상태에 넘겨 필요한 행동을 할 수 있게 했다. 

4. 디버깅
코드로 FSM을 만들다보면 예상과는 다른 행동을 하면 디버깅하기가 까다로워진다. 

도데체 지금 어떤 상태이길레 저 행동을 하고 어떤 조건이길레 저 상태로 들어갔는가를 실시간으로 확인하기가 힘들다. 로그를 찍어도 알아보기 힘든건 매한가지이다. 

![윈도우 패널 사진](/assets/images/Project/log/purikone_ingame.jpg)
*[그림 8] 기존 FSM의 문제 해결 방안 4*
그래서 각 인스턴스들이 지금 어떤 상태인지, 조건들이 지금 true인지 false인지 한눈에 알아볼 수 있는 패널을 만들어서 디버깅에 편리함을 추가했다. 

## 장단점 

위에서 말한 이야기들을 토대로 장단점을 한눈에 보기 편하게 정리하자면 다음과 같다. 

장점
편리한 사용
- update를 신경쓰지 않아도 됨
- 상태와 조건이 몇개 없다면 빠르게 구현 가능 

순수 C# 클래스
- 엔진에 대한 의존성이 없음
- 여러 프레임워크에 적용이 가능함 

단점
리엑티브 라이브러리에 대한 의존
- 리엑티브 라이브러리를 사용해본적이 없다면 살짝 까다로울 수도 있음 

규모의 부적합
- 상태와 조건이 많아지면 많아질 수록 예측 불가능한 상황이 늘어남 

## 다른 FSM 에셋과의 차이점 

FSM과 관련된 에셋은 많이 있다. 훨씬 전문적이고, 그래픽적인 요소를 통해 보기 쉽게 만들고, 사용하기도 쉽게 개발된 에셋은 많이 있다. 

하지만 **숙련만 된다면** 개발 단계에서 가볍고, 적용하기 빠르고, 출시 단계에서 성능도 좋은 에셋은 보기 드물 것이다. (학생의 눈에서 성능을 논하기는 어렵겠지만.) 

또한 순수 C# 클래스라는 점도 좋은 점이다. 이 FSM은 유니티 엔진에 대한 의존성을 최대한 배제시킨 프레임워크를 사용하다가 탄생한 FSM이다. 유니티에 대한 의존성이 없기 때문에 여러 프레임워크에 적용이 가능할 뿐더러 유닛 테스트에서도 문제될 것이 없다. 

## 첫 에셋 개발
AI의 도움을 많이 받긴 했지만 처음으로 내가 만든 코드에 자신감을 가지고 모두에게 에셋의 형태로 공개하고 싶어서 이 프로젝트를 시작했다. 

에셋에 치명적인 오류가 있거나 아마추어나 학생 단계에서는 발견할 수 없는 문제가 있다면 메일을 통해 많이 지적을 해주면 좋을거 같다. 

인디 게임을 만드시는 분들이 이 에셋을 통해서 더 빠르고 간편하게 작업을 해서 인디 개발에 재미를 잃지 않으면 좋겠다.

---
**References & Copyrights**
* **Technical Reference:** 본 에셋의 리액티브 개념은 [toRisouP님의 UniRx 강좌](https://qiita.com/toRisouP/items/48b9fa25df64d3c6a392)를 참고하여 설계되었습니다.
* **Images:** 본 문서에 사용된 도식 및 예시 이미지는 AI를 통해 생성되었습니다.